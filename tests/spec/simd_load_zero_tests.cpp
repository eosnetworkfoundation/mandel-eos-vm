// Generated by spec_test_generator.  DO NOT MODIFY THIS FILE.

#include <algorithm>
#include <vector>
#include <iostream>
#include <iterator>
#include <cmath>
#include <cstdlib>
#include <catch2/catch.hpp>
#include <utils.hpp>
#include <wasm_config.hpp>
#include <eosio/vm/backend.hpp>

using namespace eosio;
using namespace eosio::vm;
extern wasm_allocator wa;

BACKEND_TEST_CASE( "Testing wasm <simd_load_zero_0_wasm>", "[simd_load_zero_0_wasm_tests]" ) {
   using backend_t = backend<standalone_function_t, TestType>;
   auto code = read_wasm( std::string(wasm_directory) + "simd_load_zero.0.wasm");
   backend_t bkend( code, &wa );

   CHECK(bkend.call_with_return("env", "v128.load32_zero", UINT32_C(0))->to_v128() == make_v128_i32(50462976u,0u,0u,0u));
   CHECK(bkend.call_with_return("env", "v128.load64_zero", UINT32_C(0))->to_v128() == make_v128_i64(506097522914230528u,0u));
   CHECK(bkend.call_with_return("env", "v128.load32_zero", UINT32_C(10))->to_v128() == make_v128_i32(218893066u,0u,0u,0u));
   CHECK(bkend.call_with_return("env", "v128.load64_zero", UINT32_C(10))->to_v128() == make_v128_i64(9331474980934519562u,0u));
   CHECK(bkend.call_with_return("env", "v128.load32_zero", UINT32_C(20))->to_v128() == make_v128_i32(2273740164u,0u,0u,0u));
   CHECK(bkend.call_with_return("env", "v128.load64_zero", UINT32_C(20))->to_v128() == make_v128_i64(151219482297732u,0u));
   CHECK(bkend.call_with_return("env", "v128.load32_zero_const0")->to_v128() == make_v128_i32(50462976u,0u,0u,0u));
   CHECK(bkend.call_with_return("env", "v128.load64_zero_const8")->to_v128() == make_v128_i64(1084818905618843912u,0u));
   CHECK(bkend.call_with_return("env", "v128.load32_zero_offset0", UINT32_C(0))->to_v128() == make_v128_i32(50462976u,0u,0u,0u));
   CHECK(bkend.call_with_return("env", "v128.load32_zero_align1", UINT32_C(1))->to_v128() == make_v128_i32(67305985u,0u,0u,0u));
   CHECK(bkend.call_with_return("env", "v128.load32_zero_offset0_align1", UINT32_C(2))->to_v128() == make_v128_i32(84148994u,0u,0u,0u));
   CHECK(bkend.call_with_return("env", "v128.load32_zero_offset10_align4", UINT32_C(3))->to_v128() == make_v128_i32(2148470285u,0u,0u,0u));
   CHECK(bkend.call_with_return("env", "v128.load64_zero_offset0", UINT32_C(0))->to_v128() == make_v128_i64(506097522914230528u,0u));
   CHECK(bkend.call_with_return("env", "v128.load64_zero_align1", UINT32_C(1))->to_v128() == make_v128_i64(578437695752307201u,0u));
   CHECK(bkend.call_with_return("env", "v128.load64_zero_offset0_align1", UINT32_C(2))->to_v128() == make_v128_i64(650777868590383874u,0u));
   CHECK(bkend.call_with_return("env", "v128.load64_zero_offset10_align4", UINT32_C(3))->to_v128() == make_v128_i64(9548619127666445837u,0u));
   CHECK(bkend.call_with_return("env", "v128.load64_zero_offset20_align8", UINT32_C(4))->to_v128() == make_v128_i64(35208u,0u));
   CHECK_THROWS_AS(bkend("env", "v128.load32_zero", UINT32_C(4294967295)), std::exception);
   CHECK_THROWS_AS(bkend("env", "v128.load64_zero", UINT32_C(4294967295)), std::exception);
   CHECK_THROWS_AS(bkend("env", "v128.load32_zero_offset1_align1", UINT32_C(4294967295)), std::exception);
   CHECK_THROWS_AS(bkend("env", "v128.load64_zero_offset1_align1", UINT32_C(4294967295)), std::exception);
}

BACKEND_TEST_CASE( "Testing wasm <simd_load_zero_1_wasm>", "[simd_load_zero_1_wasm_tests]" ) {
   using backend_t = backend<standalone_function_t, TestType>;
   auto code = read_wasm( std::string(wasm_directory) + "simd_load_zero.1.wasm");
   CHECK_THROWS_AS(backend_t(code, nullptr), std::exception);
}

BACKEND_TEST_CASE( "Testing wasm <simd_load_zero_11_wasm>", "[simd_load_zero_11_wasm_tests]" ) {
   using backend_t = backend<standalone_function_t, TestType>;
   auto code = read_wasm( std::string(wasm_directory) + "simd_load_zero.11.wasm");
   backend_t bkend( code, &wa );

   CHECK(bkend.call_with_return("env", "v128.load32_zero-in-block")->to_v128() == make_v128_i32(50462976u,0u,0u,0u));
   CHECK(bkend.call_with_return("env", "v128.load64_zero-in-block")->to_v128() == make_v128_i64(578437695752307201u,0u));
   CHECK(bkend.call_with_return("env", "v128.load32_zero-as-br-value")->to_v128() == make_v128_i32(151521030u,0u,0u,0u));
   CHECK(bkend.call_with_return("env", "v128.load64_zero-as-br-value")->to_v128() == make_v128_i64(1012478732780767239u,0u));
   CHECK(bkend.call_with_return("env", "v128.load32_zero-extract_lane_s-operand")->to_ui32() == UINT32_C(252579084));
   CHECK(bkend.call_with_return("env", "v128.load64_zero-extract_lane_s-operand")->to_ui64() == UINT64_C(9548619127666445837));
}

BACKEND_TEST_CASE( "Testing wasm <simd_load_zero_2_wasm>", "[simd_load_zero_2_wasm_tests]" ) {
   using backend_t = backend<standalone_function_t, TestType>;
   auto code = read_wasm( std::string(wasm_directory) + "simd_load_zero.2.wasm");
   CHECK_THROWS_AS(backend_t(code, nullptr), std::exception);
}

BACKEND_TEST_CASE( "Testing wasm <simd_load_zero_3_wasm>", "[simd_load_zero_3_wasm_tests]" ) {
   using backend_t = backend<standalone_function_t, TestType>;
   auto code = read_wasm( std::string(wasm_directory) + "simd_load_zero.3.wasm");
   CHECK_THROWS_AS(backend_t(code, nullptr), std::exception);
}

BACKEND_TEST_CASE( "Testing wasm <simd_load_zero_4_wasm>", "[simd_load_zero_4_wasm_tests]" ) {
   using backend_t = backend<standalone_function_t, TestType>;
   auto code = read_wasm( std::string(wasm_directory) + "simd_load_zero.4.wasm");
   CHECK_THROWS_AS(backend_t(code, nullptr), std::exception);
}

